import numpy as np
import networkx as nx

_rtf_header = """* Topology automatically generated by moleculex
*
36  1

DEFA FIRS NONE LAST NONE
AUTO ANGLES DIHE

"""

elements_number = {
    'HT': 1,
    'HP': 2,
    'C' : 6,
    'N' : 7,
    'O' : 8,
}

elements_symbol = {
    1: 'HT',
    2: 'HP',
    6: 'C',
    7: 'N',
    8: 'O'
}

elements_mass = {
    1: 1.00800,
    2: 2.00800,
    6: 12.01100,
    7: 14.00700,
    8: 15.99900,
}

class Atom:
    """Atom"""

    name = None
    element = None
    x = 999.999
    y = 999.999
    z = 999.999

    def __init__(self, attr_dict=None, **kwargs):
        for k in kwargs:
            setattr(self, k, kwargs[k])
        if 'symbol' in kwargs:
            self.element = Element(symbol=self.symbol)
        elif 'name' in kwargs:
            symbol = self.name[:]
            self.element = Element(symbol=symbol)

class Element:
    """Element"""

    symbol = None
    number = None
    mass = None

    def __init__(self, **kwargs):
        if 'symbol' in kwargs:
            self.symbol = kwargs['symbol']
        if 'number' in kwargs:
            self.number = kwargs['number']

        assert self.symbol or self.number

        if not self.symbol:
            self.symbol = elements_symbol[self.number]
        if not self.number:
            self.number = elements_number[self.symbol]

        assert elements_symbol[self.number] == self.symbol
        assert elements_number[self.symbol] == self.number

        self.mass = elements_mass[self.number]

    def __eq__(self, other):
        if isinstance(other, Element):
            return self.symbol == other.symbol
        raise NotImplementedError

class Molecule():
    """Molecule class"""

    def __init__(self):
        self.graph = nx.Graph()

    def add_atom(self, n):
        """Add a single atom"""
        self.graph.add_node(n)

    def add_bond(self, v, w):
        """Add a single bond"""
        self.graph.add_edge(v, w)

    def remove_atom(self, n):
        """Remove a single atom"""
        self.graph.remove_node(n)

    def remove_bond(self, v, w):
        """Remove a single bond"""
        self.graph.remove_edge(v, w)

    def atoms(self):
        """Return a list of atoms"""
        return self.graph.nodes()

    def bonds(self):
        """Return a list of bonds"""
        return self.graph.edges()

    def atoms_sorted(self):
        C = filter(lambda x: x.element.symbol == 'C', self.graph.nodes())
        nodes = []
        for atom in C:
            group = []
            group.append(atom)
            neighbors = [_ for _ in self.graph.neighbors(atom) if _.element.symbol != 'C']
            for n in neighbors:
                group.append(n)
            nodes.append(group)
        return nodes

    @staticmethod
    def from_pdb(pdbfile):
        molecule = None
        in_chain = False
        current_chain = None
        current_residue = None
        for line in pdbfile:
            token = line[:6].strip()
            if not in_chain and (token in ('ATOM', 'HETATM')):
                in_chain = True
                if molecule is None:
                    molecule = Molecule()
                    atomDict = {}
                else:
                    raise NotImplementedError('Parsing multiple molecule in a single PDB file is not implemented yet.')
            if in_chain and token == 'TER':
                in_chain = False

            if in_chain and (token in ('ATOM', 'HETATM')):
                number = int(line[6:11])
                name = line[11:16].strip()
                altloc = line[16:17].strip()
                resname = line[17:20].strip()
                chainid = line[21:22]
                resnr = int(line[22:26])
                x = float(line[30:38])
                y = float(line[38:46])
                z = float(line[46:54])
                occupancy = float(line[54:60])
                bfactor = float(line[60:66])
                segid = line[72:76].strip()

                if altloc and altloc != 'A':
                    continue

                atom = Atom(name=name, resname=resname, resnr=resnr, x=x,
                        y=y, z=z, occupancy=occupancy, bfactor=bfactor)
                atomDict[number] = atom
                molecule.add_atom(atom)

            if token == 'CONECT':
                # split into chunks of 5, strip, and convert to int
                line = line[6:]
                entries = []
                for i in range(0, len(line), 5):
                    entry = line[i:i+5].strip()
                    if entry:
                        entries.append(int(entry))
                atom1 = atomDict[entries[0]]
                for i in range(1, len(entries)):
                    atom2 = atomDict[entries[i]]
                    molecule.add_bond(atom1, atom2)

        return molecule

    def to_rtf(self, rtffile, polar_carbon = True):
        v = []
        if polar_carbon:
            chmtype_map = {'C': 'ICG1', 'HT': 'HGR61', 'HP' : 'ICGE'}
            count = {'C': 1, 'HT': 1, 'HP': 1}
        else:
            chmtype_map = {'C': 'CG2R61', 'HT': 'HGR61'}
            count = {'C': 1, 'HT': 1}

        rtffile.write(_rtf_header)
        rtffile.write("RESI TUBE\n")

        # modified ##
        for group in self.atoms_sorted():
            rtffile.write("GROUP\n")
            for atom in group:
                symbol = atom.element.symbol
                atom_num = np.base_repr(count[symbol], base=36)
                count[symbol] += 1
                #if symbol == 'C' and count[symbol] % 2 == 0:
                #    rtffile.write("GROUP\n")
                chmtype = chmtype_map[symbol]
                if chmtype == 'ICG1': charge = 0.200
                if chmtype == 'ICGE': charge = -0.100
                if chmtype == 'CG2R61': charge = 0.000
                if chmtype == 'HGR61': charge = 0.000
                rtffile.write("ATOM %5s %5s %6.3f\n" %(atom.name, chmtype, charge))

        for atom1, atom2 in self.bonds():
            rtffile.write("BOND {} {}\n".format(atom1.name, atom2.name))
        rtffile.close()
    def to_impatch(self, rtffile, conectinfo):
        v = []
        count = {'C': 1, 'HT': 1}
        chmtype_map = {'C': 'CG2R61', 'HT': 'HGR61'}
        for atom in conectinfo:
            rtffile.write("PRES P%s\n" % atom.name)
            if len(conectinfo[atom]) == 2:
                atom1, atom2 = conectinfo[atom]
                rtffile.write("BOND {} {}\n".format(atom.name, atom1.name))
                rtffile.write("BOND {} {}\n".format(atom.name, atom2.name))
            if len(conectinfo[atom]) == 1:
                atom1 = conectinfo[atom][0]
                rtffile.write("BOND {} {}\n".format(atom.name, atom1.name))
        rtffile.close()

    def name_atoms(self, base=36, polar_carbon = True):
        """Assigns atom names according to the following format:
            [symbol][number]
        Where symbol is atom.element.symbol and number is the number of
        atoms of that element seen so far.

        By default, atom numbers are represented in base 36 (0-9A-Z).
        """
        v = []
        atom_names = {}
        if polar_carbon:
            count = {'C': 1, 'HT': 1, 'HP' : 1}
        else:
            count = {'C': 1, 'HT': 1}
        for atom in self.atoms():
            symbol = atom.element.symbol
            atom_num = np.base_repr(count[symbol], base=36)
            count[symbol] += 1
            atom.name = ("%s%s" % (symbol, atom_num)).upper()

    def to_pdb(self, pdbfile):
        atomnr = 0
        _atom = "ATOM  {atomnr:5d} {name:<4} {resname:<4s}{chainid:1s}{resnr:4d}    {x:8.3f}{y:8.3f}{z:8.3f}{occupancy:6.2f}{bfactor:6.2f}      {segid:<4s}{element:>2s}  \n"

        # modified ####
        for group in self.atoms_sorted():
            for atom in group:
                resname = atom.resname
                atomnr += 1
                chainid = ''
                name = atom.name
                resnr = atom.resnr
                x = atom.x
                y = atom.y
                z = atom.z
                element = atom.element.symbol
                segid = getattr(atom, "segid", "")
                try:
                    occupancy = atom.occupancy
                    bfactor = atom.bfactor
                except:
                    occupancy = 0
                    bfactor = 0
                pdbfile.write(_atom.format(**locals()))

        # write terminal record
        atomnr += 1
        _ter = "TER   {atomnr:5d}      {resname:<4s}{chainid:1s}{resnr:4d}\n\n"
        pdbfile.write(_ter.format(**locals()))


    def to_crd(self, crdfile):
        _header = "* CRD file \n*\n%10d  EXT\n"
        atomnr = 0
        _atom = "%(atomnr)10d%(resnr)10d  %(resname)-10s%(name)-8s%(x)20.10f%(y)20.10f%(z)20.10f  %(segid)-10s%(resid)-8s%(wmain)20.10f\n"
        wmain = 1.0
        crdfile.write(_header % len(self.atoms()))
        # modified #####
        for group in self.atoms_sorted():
            for atom in group:
                resname = atom.resname
                atomnr += 1
                chainid = ''
                name = atom.name
                resnr = atom.resnr
                resid = atom.resnr
                x = atom.x
                y = atom.y
                z = atom.z
                segid = getattr(atom, "segid", "")
                try:
                    bfactor = atom.wmain
                except:
                    bfactor = 1.0
                crdfile.write(_atom % locals())
